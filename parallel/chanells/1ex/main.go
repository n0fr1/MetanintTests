//Горутина-отправитель может отправлять данные только в пустой канал.
//Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.

//1. Запускается функция main. Она создает канал intCh и запускает горутину в виде анонимной функции.
//2. Функция main продолжает выполняться и блокируется на строке fmt.Println(<-intCh), пока не будут получены данные.
//3. Параллельно выполяется запущенная горутина в виде анонимной функции. В конце своего выполнения
//она отправляет данные через канал: intCh <-5. Горутина блокируется, пока функция main не получит данные.
//4. Функция main получает отправленные данные, деблокируется и продолжает свою работу.

package main

import "fmt"

func main() {

	intCh := make(chan int)

	go func() {
		fmt.Println("Go routine starts")
		intCh <- 5 //блокировка, пока данные не будут получены.
	}()

	fmt.Println(<-intCh) //получение данных из канала
	fmt.Println("The end")

}

//пример - deadlock. Отправителем данных должна быть отдельно запускаемая горутина.
//Если мы определим отправление и получение данных через канал в самой функции main, то мы столкнемся с взаимоблокировкой

// func main() {

// 	intCh := make(chan int)
// 	intCh <- 10
// 	fmt.Println(<-intCh)

// }

//но если канал буферизированный, то deadlock'a - не будет.

// func main() {
// 	intCh := make(chan int, 1)
// 	intCh <- 10
// 	fmt.Println(<-intCh)
// }

//В буферизованном блокировки на стороне пищущей горутины - происходят
//в случае отсутствия свободного места в канале.

//В не буферизованном - пищущая горутина блокируется в ожидании, когда данные
//из канала будут прочитаны читателем (другой горутиной)
